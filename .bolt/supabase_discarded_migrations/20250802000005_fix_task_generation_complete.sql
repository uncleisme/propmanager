-- Comprehensive fix for task generation and trigger functions
-- This ensures all table names and field names match the snake_case structure

-- First, fix the task number generation trigger function
CREATE OR REPLACE FUNCTION generate_task_number()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW."taskNumber" IS NULL THEN
    NEW."taskNumber" := 'MT-' || TO_CHAR(NOW(), 'YYYY') || '-' || LPAD(nextval('maintenance_task_seq')::TEXT, 6, '0');
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Drop existing triggers and recreate them on the correct table
DROP TRIGGER IF EXISTS trigger_generate_task_number ON public.maintenanceTasks;
DROP TRIGGER IF EXISTS trigger_generate_task_number ON public.maintenance_tasks;

-- Create the trigger on the correct snake_case table
CREATE TRIGGER trigger_generate_task_number
  BEFORE INSERT ON public.maintenance_tasks
  FOR EACH ROW
  EXECUTE FUNCTION generate_task_number();

-- Fix the maintenance history logging function
CREATE OR REPLACE FUNCTION log_maintenance_history()
RETURNS TRIGGER AS $$
BEGIN
  -- Log task creation
  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.maintenance_history (
      "assetId", "taskId", "actionType", "actionDate", "performedBy", details, "newValues"
    ) VALUES (
      NEW."assetId", NEW.id, 'scheduled', NOW(), NEW."createdBy", 
      'Task created: ' || NEW.title,
      to_jsonb(NEW)
    );
    RETURN NEW;
  END IF;
  
  -- Log task updates
  IF TG_OP = 'UPDATE' THEN
    -- Log status changes
    IF OLD.status != NEW.status THEN
      INSERT INTO public.maintenance_history (
        "assetId", "taskId", "actionType", "actionDate", "performedBy", details, "oldValues", "newValues"
      ) VALUES (
        NEW."assetId", NEW.id, NEW.status, NOW(), NEW."completedBy",
        'Status changed from ' || OLD.status || ' to ' || NEW.status,
        to_jsonb(OLD), to_jsonb(NEW)
      );
    END IF;
    RETURN NEW;
  END IF;
  
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Drop existing history trigger and recreate
DROP TRIGGER IF EXISTS trigger_log_maintenance_history ON public.maintenanceTasks;
DROP TRIGGER IF EXISTS trigger_log_maintenance_history ON public.maintenance_tasks;

CREATE TRIGGER trigger_log_maintenance_history
  AFTER INSERT OR UPDATE ON public.maintenance_tasks
  FOR EACH ROW
  EXECUTE FUNCTION log_maintenance_history();

-- Update the task generation function to include taskNumber
CREATE OR REPLACE FUNCTION generate_scheduled_maintenance_tasks(days_ahead INTEGER DEFAULT 7)
RETURNS TABLE(
    schedule_id INTEGER,
    task_id INTEGER,
    asset_name TEXT,
    task_title TEXT,
    scheduled_date DATE,
    work_order_created BOOLEAN
) AS $$
DECLARE
    schedule_record RECORD;
    new_task_id INTEGER;
    task_title TEXT;
    next_date DATE;
    work_order_created BOOLEAN := false;
BEGIN
    -- Loop through active schedules that are due within the specified days
    FOR schedule_record IN 
        SELECT ms.*, ma."assetName", ma."locationBuilding", ma."locationFloor", ma."locationRoom"
        FROM maintenance_schedules ms
        JOIN maintenance_assets ma ON ms."assetId" = ma.id
        WHERE ms."isActive" = true
        AND ms."nextDueDate" <= CURRENT_DATE + (days_ahead || ' days')::INTERVAL
        AND ms."nextDueDate" >= CURRENT_DATE
        -- Don't create duplicate tasks for the same schedule and date
        AND NOT EXISTS (
            SELECT 1 FROM maintenance_tasks mt 
            WHERE mt."scheduleId" = ms.id 
            AND mt."scheduledDate" = ms."nextDueDate"
            AND mt.status IN ('scheduled', 'in_progress')
        )
    LOOP
        -- Create task title
        task_title := schedule_record."scheduleName" || ' - ' || schedule_record."assetName";
        
        -- Insert maintenance task (taskNumber will be auto-generated by trigger)
        INSERT INTO public.maintenance_tasks (
            "scheduleId",
            "assetId",
            title,
            description,
            priority,
            status,
            "scheduledDate",
            "assignedTo",
            "createdBy"
        ) VALUES (
            schedule_record.id,
            schedule_record."assetId",
            task_title,
            COALESCE(schedule_record.description, 'Scheduled maintenance task'),
            schedule_record.priority,
            'scheduled',
            schedule_record."nextDueDate",
            schedule_record."assignedTo",
            'system'
        ) RETURNING id INTO new_task_id;
        
        -- Calculate next due date for the schedule
        CASE schedule_record."frequencyType"
            WHEN 'daily' THEN
                next_date := schedule_record."nextDueDate" + (schedule_record."frequencyValue" || ' days')::INTERVAL;
            WHEN 'weekly' THEN
                next_date := schedule_record."nextDueDate" + (schedule_record."frequencyValue" || ' weeks')::INTERVAL;
            WHEN 'monthly' THEN
                next_date := schedule_record."nextDueDate" + (schedule_record."frequencyValue" || ' months')::INTERVAL;
            WHEN 'quarterly' THEN
                next_date := schedule_record."nextDueDate" + (schedule_record."frequencyValue" * 3 || ' months')::INTERVAL;
            WHEN 'semi_annual' THEN
                next_date := schedule_record."nextDueDate" + (schedule_record."frequencyValue" * 6 || ' months')::INTERVAL;
            WHEN 'annual' THEN
                next_date := schedule_record."nextDueDate" + (schedule_record."frequencyValue" || ' years')::INTERVAL;
            ELSE
                next_date := schedule_record."nextDueDate" + (schedule_record."frequencyValue" || ' days')::INTERVAL;
        END CASE;
        
        -- Update schedule's next due date
        UPDATE public.maintenance_schedules 
        SET 
            "nextDueDate" = next_date,
            "updatedAt" = NOW()
        WHERE id = schedule_record.id;
        
        -- Check if work order was created (if work_orders table exists)
        work_order_created := false; -- Set to false for now since work_orders table may not exist
        
        -- Return information about created task
        RETURN QUERY SELECT 
            schedule_record.id,
            new_task_id,
            schedule_record."assetName",
            task_title,
            schedule_record."nextDueDate",
            work_order_created;
            
    END LOOP;
    
    RETURN;
END;
$$ LANGUAGE plpgsql;
